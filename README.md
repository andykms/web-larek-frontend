# Проектная работа "Веб-ларек"

Стек: HTML, SCSS, TS, Webpack

Структура проекта:
- src/ — исходные файлы проекта
- src/components/ — папка с JS компонентами
- src/components/base/ — папка с базовым кодом

Важные файлы:
- src/pages/index.html — HTML-файл главной страницы
- src/types/index.ts — файл с типами
- src/index.ts — точка входа приложения
- src/scss/styles.scss — корневой файл стилей
- src/utils/constants.ts — файл с константами
- src/utils/utils.ts — файл с утилитами

## Установка и запуск
Для установки и запуска проекта необходимо выполнить команды

```
npm install
npm run start
```

или

```
yarn
yarn start
```
## Сборка

```
npm run build
```

или

```
yarn build
```
##Базовый код
###Абстрактный класс View<T, S extends Object>
Реализует базовый абстрактный класс отображений. Все отображения наследуются прямо, либо через родственные ему классы.
Вот пример использования класса для реализации класса отображения товара.
```
class Product extends View<IProductData, IProductSettings>
```
Класс является дженериком и принимает в переменной T тип данных наследуемого класса, которые необходимо отобразить. В примере, это объект (IProductData) с полями цены и названием товара.
Вторым аргументом является тип настроек. Важно, что сам класс View ничего не знает об конкретных настройках – поля настроек необходимо передавать при вызове методов родительского класса View.
Конструктор класса принимает 3 обязательных и 1 необязательный аргумент.
```
1.	Element: HTMLElement 
```
элемент отображения
```
2.	Settings: S 
```
настройки, требует тип дженерик
```
3.	events: IEvent 
```
объект наблюдателя, требует интерфейс наблюдателя с методами on, off, emit.
```
4.	value 
```	
необязательный аргумент. Нужен, если при инициализации объектов наследуемых отображений необходимо сразу отобразить данные
Важно, предполагается, что конструктор наследуемых классов не будет переопределяться – в конструкторе View вызывается метод init – его необходимо переопределить в наследуемых отображениях, если необходима логика работы с экземпляром класса сразу при его создании. 
Абстрактный класс имеет такие методы:
```
1.	copy(settings?: S)
```
копирует объект, принимает один аргумент настроек
```
2.	render(selector: string|undefined = undefined): HTMLElement 
```
принимает необязательный аргумент селектор класса, при его отсутствии возвращает корневой элемент отображения, при селекторе – возвращает элемент по данному селектору
```
3.	getElementFromCache(selector: string): HTMLElement
`` `
принимает обязательный аргумент селектор класса. Ищет элемент в кэше (хэш-таблице) по селектору. При его отсутствии в кэше, находит элемент в DOM и записывает в кэш. Возвращает элемент с переданным в метод селектором.
```
4.	setValue(selector: string, newValue: string|attributeValues) 
```
принимает селектор элемента и новое значение – при передаче строкового значения изменяет свойство textContent элемента, при передаче объекта, реализующего интерфейс attributeValues изменяет атрибуты элемента, новым атрибутом будет ключ объекта, значением атрибута будет значение данного объекта
```
5.	addClass(selector: string, className: string)
```
принимает селектор элемента и класс, который будет добавлен элементу с данным селектором.
```
6.	toggleClass(selector: string, deletedClass: string|string[], newClasses: string|string[])
```
принимает селектор класса элемента, удаляемые классы элемента и новые классы. Удаляемые классы будут удалены, новые – добавлены. Метод принимает как одиночные классы, так и массивы классов.
```
7.	removeAttribute(selector: string, attribute: string)
```
принимает селектор класса элемента и атрибут данного элемента. Метод удаляет переданный атрибут у элемента с переданным селектором.
```
8.	removeClass(selector: string, className: string)
```
принимает селектор класса элемента и удаляемый класс. Метод удаляет класс (className) у элемента с переданным селектором(selector).
```
9.	appendChildView(selector: string, child: HTMLElement) 
```
принимает селектор класса элемента и элемент DOM. В элемент с переданным селектором (selector) добавляется потомок DOM (child). 
```
10.	removeChildView(selector: string, child: HTMLElement|undefined = undefined) 
```
метод, противоположный appendChildView – удаляет потомка. Если потомок не найдется в элементе, удаление не произойдет

###Абстрактный класс Form<T,S extends object> extends View<T,S>
Расширяет базовое представление методами для форм. Не изменяет родительские методы, в том числе конструктор. Дополнительных полей нет – предполагается что элементы форм, например теги ```input``` будут вводится в сами методы. 
Методы:
```
1.	setInputValue(selector: string, newValue: string)
```
Принимает селектор элемента Input и строку. Строка будет вставлена в соответствующее поле input.
```
2.	isValidInputValueBySelector(selector: string): boolean
```
Принимает селектор элемента Input. При валидном ```input``` элемента возвращает ```true```
